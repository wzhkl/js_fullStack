# q1.js 全局执行上下文为我们创建了两个东西：全局对象和this关键字
  new 的实现原理
    1.创建一个空对象，构造函数的this指向这个空对象
    2. 这个新对象被执行[原型]连接
    3. 执行构造函数，将属性或方法添加到this引用的对象上
    4. 如果构造函数中没有返回其他对象那么返回this，即返回创建的新对象。否则，返回构造函数返回的对象

#q2 call bind apply
 1. b.call(a) 相当于把b里面的作用域指向a里面去，第一个参数一定是this作用域要去到的地方
  第二个之后的参数是该作用域里传的要用到的值

2. b.apply(a,[]) 和call的区别是第二个参数必须是个数组

3. b.call() 或 b.aply() 此时this的作用域会指向window

4. c= b.bind(a)
   c()
   bind方法返回的是一个修改过的函数，所以该用函数该有的姿态去调用
   bind方法接受的参数是按照形参的顺序进行的

#q3 浅拷贝和深拷贝
  1. 数组解构
    let [x,y] = [1,2]
      //x=1
      //y=2
  2. 对象解构
    let {foo,bar} = {foo:'aaa',bar:'bbb'}
    //foo = aaa;
    //bar = bbb;
    注：(允许给赋值的变量重命名)
    let {foo : 'bar'} = { foo : 'abc'}
    //bar = 'abc'
  3. 浅拷贝只是第一层属性进行拷贝，当第一层的属性为基本数据类型时，新对象与原对象的互不影响
     但是如果第一层的属性值是复杂类型，那么新对象和源对象的属性值其实指的是同一块内存地址

     深拷贝是将对象及其值复制过来，两个对象修改其中任一个的值，另一个不会改变

#q4 闭包
  闭包是指有权限访问另一个作用域的中的变量的函数
    1. 能够访问函数定义时所在的词法作用域(还能阻止其回收)
    2. 私有化变量
    3. 模拟块级作用域

# q5 数组去重
  Set indexOf includes map reduce

# q6 防抖节流

# q7 __proto__ 和 prototype 关联  判断数据类型
  __proto__是每一个实例都有的属性，可以访问[prototype]属性，实例的__proto__与其构造函数的prototype指向的是同一个对象
  准确判断数据类型:
    Object.prototype.toString.call()